name: ğŸ“¦ Continuous Integration # Workflow name that appears in GitHub Actions UI

concurrency: # Prevents multiple runs of the same workflow
  group: ${{ github.workflow }}-${{ github.ref }} # Defines the grouping key
  # If a new run starts for this same concurrency group, automatically cancel any currently running one.
  cancel-in-progress: true # Safety & efficiency flag set to true.

on: # Defines the triggers that cause this workflow to run.
  pull_request: # Runs when someone opens or updates a pull request targeting these branches.
    branches: [main, develop] # Remove the 'develop' branch reference if it doesn't exist
  push: # Runs when code is pushed or merged from PR directly to these branches.
    branches: [develop] # Remove the 'develop' branch reference if it doesn't exist
  workflow_run: # Trigger when the changelog workflow completes
    workflows: ['ğŸ“„ Auto Update Changelog']
    branches: [main] # Only run when changelog completed on the main branch
    types: [completed]

permissions:
  contents: read # Needed to read repository files.
  checks: write # Allows the workflow to report results directly to the GitHub Checks API.
  actions: write # Upload artifacts to Actions storage.

env:
  NODE_ENV: production # Keeps all downstream workflows (release and deploy) consistent when downloading artifacts.

jobs: # Defines all the major automated tasks GitHub will run
  build: # Defines a build job, compiles the project or prepares production-ready output.
    if: >
      ${{
        (github.event_name != 'workflow_run') ||
        (!contains(github.event.head_commit.message, '[skip ci]')) ||
        (github.event_name == 'workflow_run' && github.event.workflow_run.conclusion == 'success')
      }}
    name: Build Project # Gives the job a human-readable name which appears in GitHubâ€™s â€œActionsâ€ UI.
    runs-on: ubuntu-latest # Run this job on the latest Ubuntu Linux virtual machine.
    timeout-minutes: 10 # Automatically cancel an entire job if it runs longer than set minutes.

    # âš™ï¸ Strategy matrix, if node-version: [20.x, 22.x] it runs the build on both Node 20.x and 22.x for compatibility.
    strategy:
      fail-fast: false # Continue with Node 22 even if Node 20 fails, if node-version: [20.x, 22.x]
      matrix:
        node-version: [20.x]

    steps:
      # ğŸ“¥ Step 1: Downloads the repositoryâ€™s code into the runner.
      - name: Checkout
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          fetch-depth: 0

      # âš¡ Step 2: Installs Node.js on the runner and enables npm caching.
      - name: Setup Node.js ${{ matrix.node-version }}
        uses: actions/setup-node@v4
        with:
          node-version: ${{ matrix.node-version }} # From the matrix above
          cache: 'npm' # Speeds up workflow runs by caching dependencies.

      # ğŸ§¾ Step 3: Display environment info (for debugging clarity)
      - name: Show environment info
        run: |
          echo "ğŸ“¦ Node version: $(node -v)"
          echo "ğŸ“¦ npm version: $(npm -v)"
          echo "ğŸ’» OS: $(uname -a)"
          echo "ğŸ”§ Working directory: $(pwd)"

      # ğŸš€ Step 4: Cache only the npm download cache (NOT node_modules)
      - name: Cache npm
        uses: actions/cache@v4
        with:
          # Caching ~/.npm only allowing `npm ci` to reinstall node_modules cleanly but MUCH faster.
          # Caching node_modules is unsafe, platform-specific, easily corrupted, and causes missing binaries
          path: ~/.npm

          # Lockfile hash ensures cache is invalidated when dependencies change
          key: ${{ runner.os }}-npm-cache-${{ matrix.node-version }}-${{ hashFiles('**/package-lock.json') }}

          # Broader fallback keys if exact key is unavailable
          restore-keys: |
            ${{ runner.os }}-npm-cache-${{ matrix.node-version }}-  # Same OS + Node + npm cache
            ${{ runner.os }}-npm-cache-                             # Same OS + npm cache

      # ğŸ“¦ Step 5: Deterministic installation using npm ci
      - name: Install dependencies
        run: |
          echo "ğŸ“¦ Installing dependencies with npm ci..."

          # We ALWAYS run npm ci because:
          # - It's the only guaranteed reproducible install
          # - Uses package-lock.json for exact versions
          # - It wipes node_modules and rebuilds correctly for the current OS
          # - Combines with ~/.npm cache to be fast AND correct

          npm ci --include=dev

      # ğŸ§© Step 6: Build the project.
      - name: Build project
        run: |
          if grep -q '"build"' package.json; then
            echo "ğŸ§© Running build process..."
            npm run build
          else
            echo "âš ï¸ No 'build' script found in package.json, skipping build..."
            echo "ğŸ’¡ To enable build, define a 'build' script in package.json, e.g.:"
            echo '    "scripts": { "build": "vite build" }'
            exit 1
          fi

      # âœ… Step 7: Strong verification - Helps catch cases where the build command ran but didnâ€™t output anything.
      - name: Verify build output
        run: |
          if [ -d "dist" ] || [ -d "build" ] || [ -d "out" ]; then
            echo "âœ… Build output exists"
          else
            echo "âš ï¸ No build output found"
            exit 1
          fi

      # ğŸ“¤ Step 8: Upload build artifacts for re-use by release and deployment workflows.
      - name: Upload build artifacts
        if: success()
        uses: actions/upload-artifact@v4
        with:
          name: build-output
          path: |
            build
            dist
            out
          if-no-files-found: warn
          retention-days: 7 # Auto-delete build artifacts after 7 day to save storage

      # ğŸ§¾ Step 9: Smart Summary
      - name: CI workflow summary
        if: always()
        run: |
          if [[ "${{ job.status }}" == "success" ]]; then
            echo "âœ… CI job completed successfully"
          elif [[ "${{ job.status }}" == "failure" ]]; then
            echo "âŒ CI job failed"
          else
            echo "âš ï¸ CI job ended with status: ${{ job.status }}"
            exit 1
          fi
